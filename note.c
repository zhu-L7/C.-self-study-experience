// .c文件中编译器会按照C的语言来编译代码； .cpp文件中编译器会按照C++的语言来编译代码.

// 两个正斜杠表示一个行注释，只能注释一行.(这是C++的注释风格).

/* 两个正斜杠和两个*号分居两边，
表示一个块注释，可以注释多行,缺点是不可以嵌套（即以/*开始到后面的第一个*/
//    结束）,这是C语言的注释风格. */

// 注释内容不参与编译.


/* #include表示导入一个头文件；std(standard)表示一个标准库；.h表示头文件;
i指input表示标准输入库；o指output表示标准输出库. */

#include<stdio.h>// <>表示导入系统文件； ""表示导入自定义文件

int main()/* int表示数据类型为整形，如果出现在函数中则表示函数的
返回值; main表示程序的主函数，是程序的入口，程序有且仅有一个主函数; 
()里面表示函数的参数，函数的参数可以有多个，中间用逗号隔开. */

{
	printf("hello world!\n");
	return 0;
}

// {}里的内容表示函数体、代码体或程序体.

/* printf是stdio.h中系统提供的库函数，表示在标准输出设备上打印字符串;
 ""里内容称为字符串.      
 
           注意：比较两个字符串大小是否相等不能用==，应该用一个库函数，即strcmp，
                 对应的头文件是string.h
                          如：#include<string.h>
                              strcmp(password,"abcd")==0表示password与"abcd"相等.

                              if("abc"=="abcdef") 这样写是在比较两个字符串的首字符的地址.
        */

/* return如果出现在其他函数中表示函数结束，如果出现在main函数中表示
程序结束. */

/* 0表示函数的返回值要和函数返回值类型对应，比如0是整数，int也是整型; 写0不写1等数字是
因为人们约定熟成的习惯（C语言代码正常运行返回一般为0，异常运行或终止返回一般为1). */

// ; 表示一条语句的结束.

//c语言中规定：变量要定义在当前代码块的最前面(注意是当前代码块，不是整个代码块).

/* 变量创建的语法：数据类型 变量名 = 变量初始值
（如int a = 10, 即输入一个整形变量a的初始值为10). */

//  变量的命名：1.有意义（如int age） 2.必须由字母、数字、下划线组成
// （不能有特殊字符，不能以数字开头，不能是关键字）.

// 注意:对变量进行定义命名的时候最好带上一个初始值，不带上的话编译器可能会默认初始值为
// 随机数，影响后面的计算结果.

/* 标识符：即指定义的变量、常量，注意：标识符不可以是关键字，
是由字母、数字、下划线组成，但第一个字符不可以是数字
（如int 12a=10应为int a=10或int _a=10或int _12a=10). */

/* char
       是一个字符类型，格式：char ch = 'A';
                             printf("%c\n",ch);
 其中ch表示向内存申请的一块空间，用来存储A这个数据； %c表示打印字符对应格式的数据. */

/* %d表示打印整形十进制数据，是打印有符号的整数(会有正负数).
   %u表示打印无符号的整数(没有负数).
   %f表示打印浮点数字，即小数.
   %p表示以地址的形式打印.
   %x表示打印16进制的数字.(以0x开头,如0xFF)
   %o表示打印8进制的数字.(以0开头,如07)
   %s表示打印字符串.
   %zu表示打印字符串大小（与sizeof配用). 
   */

/* int表示整形； short表示短整形； long表示长整形； char表示字符数据类型； 
long long表示更长的整形； float表示单精度浮点型； double表示双精度浮点型. */

/* float
        格式：float a=5.0f;
              printf("%f\n",a);  
        
        注意：float a=5.0,编译器会默认为dounle类型
              float a=5.0f,编译器会默认为float类型.  */

/* double
         格式：double a=5.00;
               printf("%lf\n",a);
 比float更精确. */

/* 计算机中的单位(储存单位)：
 1bit(比特位)=1正电（或1负电） 1byte（字节）=8bit  1kb（千字节）=1024b（b为byte缩写）    
 1mb（兆字节）=1024kb         1gb（吉字节）=1024mb     1tb（太字节）=1024gb      
 1pb（拍字节）=1024tb         eb（艾字节）、zb（泽字节）、yb（尧字节）进率都为1024
   其中
   int、long、float是4个字节；  long long、double是8个字节；
   char是1个字节；  short是2个字节.
 */

/* 全局变量：指定义在主函数代码块（{}）之外的变量，具有外部链接属性(即可以在另一个文件内使用）.
   局部变量：指定义在代码块内的变量.

   当局部变量与全局变量名称相同的时候，局部变量优先.

   全局变量、静态变量都是放在静态区.
   全局变量、静态变量不初始化时，默认初始化为0.
   局部变量是放在栈区，不初始化时，默认是随机值.
   
   注意：尽量避免相同，相同时容易产生bug. */

/* scanf
        表示输入函数，格式：scanf("%d%d",&num1,&num2);
 其中
 %d个数指输入的整形数据的个数； &是取地址符号.
      注意：对于数组时可以不写&符号，因为数组名本身就是地址,字符串也不用写&(因为字符串本质上是字符数组).
            
            scanf 函数的字符串输入参数要求缓冲区大小必须是 unsigned 类型,如：
                                                                            scanf_s("%99s", password, (unsigned)sizeof(password));
                                                                            其中sizeof的作用是计算字符数组 password 的大小（字节数）,
                                                                            并将其作为参数传递给 scanf_s，以确保输入的字符串不会超出数组的边界。

           if(scanf("%d %d",&n,&m)==2)
           else
           这里scanf只读取两个数据，返回2，if执行，如果输入三个数据scanf也只读取前两个数据，返回值也是2，所以if肯定执行，else不会执行.

      */

/* 作用域：指代码能够发生效果的领域范围.
 局部变量的作用域是变量所在的{}内，全局变量的作用域是整个工程(包括全部源文件). */

/* 在另一个源文件里的全局变量，在这个源文件中也同样能够生效，但需要加一个声明，
声明外部符号是extern，如：一个文件里的int a=10; 在另一个文件里用格式为：extern int a;. */

/* 生命周期：指变量的创建到变量的销毁的一个阶段.(和作用域相似)
局部变量的生命周期：进入作用域开始到出作用域结束； 全局变量生命周期：整个程序. */

/* #define _CRT_SECURE_NO_WARNINGS 1: 写在源文件的第一行； 作用是当输入平台认为可能
不安全的C语言函数（如：scanf、strcat等）时，可以使平台不判错； 如果不使用这段代码，
也可以使用平台提供的函数（如：在visual studio中关于scanf提供的函数为scanf_s）. */

/* 常量分类：
  1.字面常量.  2.const修饰常变量.  3.define定义的标识符常变量.  4.枚举变量. */

// 字面常量：直接写出的数值，如30,3.1,'w',"abc"等.

/* const
         修饰变量，使修饰的变量具有常属性，格式：const 数据类型 变量名=常量值
        （如：const int a=7,即指数据整形a为常量7，a虽被定义为常量值，但本质是变量，且具有
         常属性，所以叫常变量,被修饰的变量后续不会被更改）. 
         
         
         const修饰指针变量：
                    const放在*左边：p指向的对象不能通过p来改变，但是p变量本身的值是可以改变的.
                           
                            int n=100;
                            int const* p;
                            *p=20;            此行不可行.
                            p=&n;             此行可行.

                    const放在*右边：p指向的对象是可以通过p来改变的，但是不能修改p变量本身的值.
                            
                            int n=100;
                            int num=20;
                            int* const p=&num;
                            *p=0;             此行可行.
                            p=&n;             此行不可行.
 */

/* #define   定义常量和宏.
            
       定义常量时格式：#define 常量名 常量值（如：#define day 7,即指定义常量day为7).
       
       定义宏时：与函数相似.
                 格式如下：
                           #include<stdio.h>
                           #define ADD(x,y) ((x)+(y))
                           int main()
                           {
                              int sum=ADD(2,3）；
                              printf("sum=%d\n",sum);
                              sum=10*ADD(2,3);
                              printf("sum=%d\n",sum);
                              reruen 0;
                            }
                            运行结果为sum=5   sum=50. */

/* 枚举常量： 
            枚举表示一一列举； 枚举关键字为enum.
            格式：enum color
                 {    red,            默认输出值为0
                      blue,           默认输出值为1
                      yellow          默认输出值为2
                  };
                 int main()
                 { printf("%d\n",red);
                   printf("%d\n",yellow);
                   printf("%d\n",blue);
                   return 0;
                  }    运行结果为：0,2,1
      其中，red、blue、yellow即指枚举常量.  */

/* 字符串
         由双引号引起的一串字符称为字符串字面值，简称字符串.
     "abc"即为一个字符串，等于{'a','b','c','\0'}, 其中'\0'(是转义字符)指字符串的
     结束标志,不算字符串的内容，'\0'也可以换做0(\0的ASCII 码值为0)；
     每个字符都有对应的值，比如a对应的值为97，其中97就是a的“ASCII 码值”，这种
     对字符编值的方式就叫作“ASCII 编码”； ASCII 码值可以通过查表得知.
         */

// 三字母词：即指三个字符连在一起会转换为一个其它字符.

/* 转义字符
           可以转变原来的意思.
        \n 表示换行； 
        \t 表示水平制表符； 
        \\ 表示一个反斜杠,防止被解释为一个转义序列符（如：\\t表示\t）；
        \' 表示一个字符 '； 
        \" 表示一个字符 "； 
        \ddd 中ddd表示1到3个八进制的数字（用法：如printf("%c\n",'\132');运行结果为Z, 
        其中\132为三个八进制数字的转义字符，Z是132作为八进制代表的那个十进制数字对应
        的ASCII 码值对应的字符，即132对应的十进制数字为90,90对应的字符为Z)；
        \xdd 中dd表示2个16进制的数字，用法与\ddd相同.
        */
        
/* strlen
         用来求字符串的长度，计算'\0'之前的长度，与头文件#include<string.h>配对.
         格式： #include<stdio.h>
                #include<string.h>
                int main()
                { 
                  printf("%zu\n",strlen("asdfwfa"));
                  return 0;
                }  
                运行结果即为对应的字符串长度.
           注意：如char arr[8]={'1','2','3'};
                   输出的字符串长度为3，因为编译器会默认未初始化的部分为'\0',
                   这种情况称为不完全初始化.
                 如char arr[]={'1','2','3'};
                   输出的字符串长度为随机值. */

/* if选择语句
             格式例子：#include<stdio.h>
                       int main()
                      {int input=0;
                       printf("你会去学C语言吗？(选择0 or 1):>");
                       scanf("%d",&input);
                       if(input==1)
                       {printf("坚持，你会有好offer\n");
                       }
                       else
                      {printf("放弃，回家卖红薯\n");
                       }
                       return 0;
                       }   
                       运行结果： 输入1时为，“坚持，你会有好offer”
                                  输入0时为，“放弃，回家卖红薯” 
                       
                       注意：if()                            if()
                             {                               {
                             }                               }
                             else if()                       if()
                             {                               {
                             }                               }
                             else                            这两个是独立关系，
                             {                               两个都会执行.
                             }
                             这三个是互斥关系，
                             只会执行一个句式.
             */

/* while循环语句
                格式例子：#include<stdio.h>         #include<stdio.h>
                          int main()                int main()
                          {                         {
                           int i=1;                 int i=1;
                           while(i<=10)               while(i<=10)
                           {printf("%d",i);         {if（i==5）
                            i++;                     {break;
                           }                         }
                           return 0;                printf("%d",i);
                          }                         i++;}
            运行结果为：1,2,3,4,5,6,7,8,9,10.        return 0;                                                               
                                                    }           
                                                    此时表示i=5时跳出循环，
                                                    即运行结果为：1,2,3,4.
其中 int i=1表示输入循环的初始值为1； i++表示在循环内i从初始值开始增加（i--相反）；
     break表示直接跳出循环； continue表示循环直接跳回到while语句的判断部分，用于终止
     本次循环，将不执行continue以后的代码部分（如将上面例子的break换成continue的话将
     造成死循环，输出结果仍为1,2,3,4）.           */

/* Add
      表示自定义函数.  格式：  #include<stdio.h>
     （自己设计函数）          int Add(int x,int y)              
                              { int z=x+y;
                                return z;
                              }
                               int main()
                              {int num1=10;
                               int num2=20;
                               int sum;
                               sum=Add(num1,num2);
                               printf("sum=%d\n",sum);
                               return 0;
                              }       
                          运行结果为sum=30；
                  其中int是函数的返回类型； Add是函数名； （）里的内容是函数的参数；
                  {}里的内容是函数体，用于完成所给定的任务； num1与x对应，num2与对
                  应，sum对应z； Add(num1,num2)即表示num1+num2.
                  */

/* 数组
       表示一组相同类型元素的集合.
                格式：#include<stdio.h>     
                      int main()     
                      {int arr[10]={1,2,3,4,5,6,7,8,9,10};     
                       int i=0;     
                       while(i<10)     
                       {printf("%d\t",arr[i]);     
                        i++;     
                        }     
                        return 0;     
                        }     
                       运行结果为：1 2 3 4 5 6 7 8 9 10.
        其中int arr[10]={1,2,3,4,5,6,7,8,9,10}表示定义一个存放10个整型数字的数组，
        int表示数组类型（可换为float、char等）， arr表示数组名称（可换）， 10表示
        数组的数据个数.
                 格式：#include<stdio.h>
                       int main()
                       {int arr[10]={1,2,3,4,5,6,7,8,9,10};
                        printf("%d",arr[4]);   这行代码表示以下标的方式访问元素.
                        return 0;
                        }
                        运行结果为：5.
        其中arr[4]中的4为数组的下标， 数组默认定义的下标是从0开始的，即以上为例1对应
        下标0，2对应下标1，8对应下标7；
        int arr[10]={0}与int arr[10]等价，int arr[]={1,2,3,4}与int arr[4]={1,2,3,4}
        等价；  数组里也可以放字符，如char ch[10]="hello bit"(数组里放字符时需要把{}
        换成"",并且需要预留一个位置放'\0').


        定义数组不完全初始化时，默认未初始化部分为0.


        函数传参数组时传的是数组的首元素地址，即(int arr[])就相当于(int* arr)，函数体
        中arr[0]就相当于*(arr+0),arr[1]就相当于*(arr+1).


        数组在内存中是连续存放的，随着数组下标的增长，元素的地址也在有规律地增长(低地址到高地址).


        数组越界:
           数组下标是从0到n-1，如果使用了小于0或者大于n-1的下标时，就形成了越界访问，编译器会随机打
           印越界部分(越界部分是随机值).
           注意:编译器不一定会报错，但是并不意味着程序是对的，一维数组和二维数组都有数组越界的情况.


        一维数组的数组名表示首元素地址，二维数组的数组名表示第一行的地址(即第一个一维数组的地址).

        例外:sizeof(数组名)，这里表示计算整个数组的大小.
             &(数组名)，这里表示取出整个数组的地址.
       */

/* 操作符
         包括算术操作符、移位操作符、位操作符、赋值操作符、单（双、三）目操作符、
         关系操作符、逻辑操作符、条件操作符、逗号表达式、下标.
 

 算术操作符： +  -  *  /  %
             / 表示除，运算结果为除数，符号两端都是整数的时候，执行的是整数
             除法， 当符号两端只要有一个浮点数的时候，执行浮点数除法.(如：int a=5/2,
             输出结果为2或者，float a=7.0/2,输出结果为3.50)；

             % 表示取模，运算结果为余数，符号两端只能是整数. （如：int a=5%2,输出结果为1）.
             

 移位操作符： >>  << 
             其中“位”指的是2进制位； <<指左移操作符， >>指右移操作符(分为算术移位、逻辑移位).
           
           左移操作符规则：左边丢弃，右边补0.
           右移操作符规则：算术移位中，右边丢弃左边补原符号位.
                           逻辑移位中，右边丢弃左边补0.

           注意：移动的是二进制位的补码.
                 移位操作符不支持浮点数.
                 右移操作符中，大多编译器都是采用的算术移位.
                 不能移动负数位、浮点数位.

               int a=-7;
               int b=a＜＜1;            具体计算查看B站鹏哥C语言P67 1:24:45.
               printf("a=%d\n",a);
               printf("b=%d\n",b);
               return 0;
              运行结果为：a=-7  b=-14.


 位操作符： &按位与  |按位或   ^按位异或   其中“位”都指2进制位.

              int a=3;                      3的补码为00000000000000000000000000000011
              int b=-5;                    -5的补码为11111111111111111111111111111011
              int c=a&b;                    c的补码为00000000000000000000000000000011
              printf("c=%d\n",c);
              return 0;
              运行结果为：c=3.

         按位与运算规则：有0则0，两个都为1则1.
         按位或运算规则：有1则1，两个都为0则0.
         按位异或运算规则：相同为0，相异为1.


 赋值操作符： =  +=  -=  *=  /=  %=  &=  ^=  |=  >>=  <<=
           这些都叫复合赋值符；
           a=a+3的等号意思是把a+3赋值给a，简写成a+=3； a=a-3简写成a-=3，其它的几个
           赋值符同理.
          

 单（双、三）目操作符： !  -  +  &  sizeof  *  ~  --  ++  (类型)
         其中单、双、三的区分是看操作数的个数，比如：a+b中+的操作数为a、b两个，即为
         双目操作符.


   单目操作符：
             ！表示逻辑反操作，（C语言中表示真假，默认0为假，非0为真），即如果是
             int a=5; printf("%d",!a);运行结果则为0，即！表示输出结果与输入相反，
             输入真则输出假，输入假则输出真（一般输入假，反操作后输出默认为1）.

             - 表示负值； + 表示正值（一般正号都会省略）.

            sizeof 表示计算变量、数组或数据类型所占空间的大小（以字节为单位）.
      其中计算变量时格式为：
                          int a=10;
                          printf("%d\n",sizeof(a));
                          printf("%d\n",sizeof(int));
                          printf("%d\n",sizeof a);
                          这几种写法均可.
                          但是printf("%d\n",sizeof int);不行
                  运行结果均为：4

        计算数组时格式为： int arr[10]={0};
                           printf("%d\n",sizeof(arr));
                           运行结果为：40. (计算数组的大小，不管数组里装了几个数，
                           数组里有10个位置，一个位置占4个字节)

        计算数组个数：#include<stdio.h>
                      int main()
                      {int arr[10]={0};       
                       int sz=0;              
                       sz=sizeof(arr)/sizeof(arr[0]);
                       printf("sz=%d\n",sz);
                       return 0;
                       }
                       运行结果为：10
                其中int arr[10]={0}与int arr[10]是等价的，int sz=0与int sz是等价的.


            ~ 表示对一个数的2进制按位取反（即0为1,1为0）.
            格式：#include<stdio.h>
                  int main()
                  {int a=0;
                   int b=~a;
                   printf("%d\n",b);
                   return 0;
                   }
                   运行结果为：-1.
             其中int b=~a表示b为有符号的整形，它的2进制序列的最高位就是符号位，且1表
             示负数，0表示正数；
             a=0是整形，为4个字节，32个比特位，其2进制序列为000000000000000000000000
             00000000，则b的2进制序列为11111111111111111111111111111111（符号位是1，
             表示负数），此为2进制的补码，但是打印是输出2进制的原码,
             原码-->反码-->补码：  原码为111111时，转反码为100000（即符号位不变，其
             它按位取反），转补码为100001（即在反码的基础上加1），
             则b的2进制补码的原码为10000000000000000000000000000001，即输出-1.


           ++ 分为前置++和后置++.
           格式：int a=10;
                 int b=a++;
                 运行结果为：a=11,b=10.
              其中a++为后置++，计算方法为先使用a（即先算int b=a;），再使用++（即算a=
              a+1）；
              ++a为前置++，计算方法为先使用++（即先算a=a+1），在使用a（即算int b=a）,
              则以上为例的话，运行结果为a=11,b=11.


           -- 分为前置--和后置--.
           格式用法与++相同，只是+1改为-1即可.


          （类型） 表示强制类型转换.
           格式：int a=(int)3.14
           其中3.14是浮点数，而int a表示整形，所以可以加（int）来把3.14强制转换为整
           形，去掉小数点及后面小数.


           &表示取地址； 
           
           
           * 表示间接访问操作符(解引用操作符).
           *p中*表示对p进行解引用，通过p里面存的地址找到p所指的对象(*p就是p所指的对象).


 关系操作符： >  >=  <  <=  !=  ==
            其中!=表示不相等；  ==表示相等.


 &&逻辑与  ||逻辑或：

           int a=3;
           int b=0;
           int c=a&&b;            &&是并且的意思.
           int d=a||b;            ||是或者的意思.
           printf("%d\n",c);
           printf("%d\n",d);
         运行结果为：c=0
                     d=1.

           int i=0,a=0,b=2,d=4,e=1,f=2,g=3,r=0;
           i=a++||++b||d++;
           r=e++&&++f&&g++;
           printf("a=%d  b=%d  d=%d  i=%d",a,b,d,i);
           printf("e=%d  f=%d  g=%d  r=%d",e,f,g,r);
           运行结果为：a=1  b=3  d=4  i=1
                     e=2  f=3  g=4  r=
       注意：对于逻辑与，左边为假右边不计算.
            对于逻辑或，左边为真右边不计算.
            

 条件操作符： exp1?exp2:exp3(也叫三目操作符)
             格式：int a=10;
                   int b=30;
                   int max;
                   max=(a>b?a:b);
                   运行结果为：max=30.
                其中exp指的是表达式，计算方法：当a>b成立时，把a的值赋给max,当a>b不成
                立时，把b的值赋给max(口诀：真真假，假假真)，  这样就可以不使用循环来
                解决问题，简化了运算.


 逗号表达式： ，
           即可以用逗号操作符（就是逗号本身）来隔开的一段表达式.
           从左到右依次计算，整个表达式的结果是最后一个表达式的结果.
           int a=1;
           int b=2;
           int c=(a＞b,a=b+10,a,b=a+1);
           printf("c=%d",c);
          运行结果为：c=13.


 下标： []  ()  .  ->
       []表示下标引用操作符（如arr[4]中的[],即为下标引用操作符，4为数组里数字对应的下
       标, arr和4就是[]的操作数， 但是对数组初始化定义的时候的[]不是操作符，如：
       int arr[]={1,2,3,4}中的[]不是操作符）.      
                   举例如下：
                   int arr[10]={1,2,3,4,5,6,7,8};  这行中的[]不是操作符,其中[]内不可以为变量.
                   int n=3;
                   arr[n]=20;                      这行中的[]是操作符, 其中[]内可以为变量，解
                                                   释为对数组中第4个数赋值为20.


      （）表示函数调用操作符.
       格式：int Add(int x,int y)
             {int z=0;
              z=x+y;
              return z;
              }
             int main()
             {int a=10;
              int b=20;
              int sum=Add(a,b);
              printf("%d\n",sum);
              return 0;
              }
              运行结果为：30
          其中Add（a，b）中的（）即为函数调用操作符,Add,a,b三个都是()的操作数.


        .和->用于结构体中.
     */ 


// EOF即end of file是文件结束标志，它本质上的值为-1.


/* C99标准之前的编译器，数组的大小必须是常量或者常量表达式.
   
   C99标准之后的编译器，数组大小定义支持变常数组，允许数组的大小是变量，
   但是这种情况不能对数组初始化. */


// 关键字： auto  break  case  char  const  continue  default  do  double  else
//          enum  extern  float  for  goto  if  int  long  register  return  
//          short  signed  sizeof  static  struct  switch  typedef  union  void
//          unsigned  volatile  while
//          注意：定义变量时变量名不能是关键字.


// typedef 是类型命名，可以理解为类型重命名.
//          如：typedef unsigned int uint;
//              unsigned int num1=0;  (1)
//              uint num2=0;  (2)
//            (1)与(2)两行代码是相同的.


// static 可以修饰局部变量、全局变量和函数.
//
// 修饰局部变量时：局部变量出了作用域是不会被销毁的，被修饰的局部变量称为静态局部变量.
//                 (本质上static修饰局部变量的时候，改变了变量的储存位置，从
//                 栈区变为了静态区,生命周期变长，变得个整个程序一样长).
//     如：
//          #include <stdio.h>
//          viod test()
//          {
//              int a=1;             此行代码改为static int a=1;
//              a++;                 运行结果为：2 3 4 5 6 7 8 9 10 11     
//              printf("%d",a);
//           }
//          int mian()
//          {
//              int i=0;
//              while(i<10)
//              {
//                  test();
//                  i++; 
//              }
//               return 0;
//           }
//          运行结果为：2 2 2 2 2 2 2 2 2 2
//
// 修饰全局变量时：被修饰的全局变量(称为静态全局变量)外部链接属性变成了内部连接属性，其它源文件
//                 不能再使用到这个全局变量.
//
// 修饰函数时：被修饰的函数(称为静态函数)外部链接属性变成了内部连接属性，其它源文件无法使用.


//  在函数命名时加viod时，这个viod的意思是不需要返回.
//   如：viod test
//       {
//          printf("hello world\n");
//        }
//       其中不需要写return z;之类的结束返回代码.(如果没有viod就需要写)


//  register 是寄存器变量，作用是建议变量放到寄存器里.
//           格式： register int num=3;即为建议编译器把num=3存放到寄存器中.
//                  (只是建议，决定由编译器来，但是现在的编译器大多都会自动
//                  地把一些数据存放到寄存器中，不用自己加register).


//  0x指16进制数.


//  指针：是内存中一个最小单元的编号，也就是地址，存放指针(地址)的变量就叫指针变量.
//       用法如下：
//                int main()
//                 {
//                    int a=10;
//                    int* p=&a;          *是指针对应的符号(说明p是指针)，p是指针变量(指针的名字)，
//                                        int是指针指向的对象(说明p对应的a的地址是整型).
//                    printf("%p\n",p);            
//                    return 0;
//                  }
//                 运行结果是a存储在内存里的地址. 
// 
//    拓展：int *p=NULL;
//          其中NULL指空指针（相当于0）.
//
//    注意：平时口语中说的指针，通常是指指针变量.


//  * 是解引用操作符
//      运用如下：int main()
//                {
//                    int a=10;
//                    int* p=&a;
//                    *p=20;                 此行代码意思是通过p中存放的地址，找到p所指的对象，
//                                           *p就是p所指的对象(即a，*p=20就是a=20).
//                    printf("%d\n",a);
//                    return 0;
//                 }
//                 运行结果为：20.


//  指针变量的大小： 32位机器上的地址是32比特位，对应4个字节，所以指针变量的大小为4个字节.
//                   64位机器上的地址是64比特位，对应8个字节，所以指针变量的大小为8个字节.
// 
//          如：int main()
//              {
//                 printf("%zu\n",sizeof(char*));
//                 printf("%zu\n",sizeof(short*));
//                 printf("%zu\n",sizeof(int*));
//                 printf("%zu\n",sizeof(float*));
//                 printf("%zu\n",sizeof(double*));
//                 printf("%zu\n",sizeof(long*));
//                 printf("%zu\n",sizeof(long long*));
//                 return 0;
//               }
//                运行结果：x64时结果为8，x86时结果为4.
//          注意：不管是什么类型的指针，都是在创建指针变量.


//  指针变量的创建：  int* p;或int *p.
//        注意：定义多个变量时，每个变量名之前都要加*.
//        (如：int *p1,*p2,*p3;  错误格式：int *p1,p2,p3;).


//  指针类型决定了指针在被解引用的时候访问几个字节(决定了指针+-1跳过几个字节).
//  如：int*的指针解引用访问4个字节，char*的指针解引用访问1个字节.
//  
//  注意：int*和float*虽然解引用时访问的都是4个字节，但是不能混用，因为它们的存储方式不同.


//  野指针：野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的).
//        int main()
//        {
//           int* p;
//           *p=10;
//           return 0;
//        }
//        其中p就是野指针(没有初始化).
// 
//        当指针越界访问时，越界部分指针是野指针.
//        当指针指向的空间释放，也会造成野指针.


//  C语言标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置(向后越界部分)的指针比较，但
//                 是不允许与指向第一个元素之前的那个内存位置(向前越界部分)的指针进行比较。


//  零地址不能访问.
//          
//       需要换种方法对其赋值：
//                        int* p3=NULL;
//                        if(p3!=NULL)
//                        {
//                           *p3=100;
//                        }
//                        return 0;
//
//       当指针不知道初始化为什么值时，可以初始化为NULL.
//       当指针指向的空间释放时，可以使其值为NULL.


//    int* test()
//    {
//       int a=10;                   此处的a出了test函数将会被销毁.
//       return &a;
//    }
//    int main()
//    {
//       int* p=test();
//       if(p!=NULL)                 此行代码没有作用，因为p一定不是NULL.
//       {
//          printf("%d\n",*p);       这里a已经销毁，但是仍能输出10，原因是*p通过p的地址仍能找到a所在的内存空
//       }                           间，但是这块内存空间并不属于a了，只是10仍在，如果这块内存空间没有被使用
//       return 0;                   (即没有被覆盖)，*p找到的就还是10.
//     }                             如果在int* p=test();和if(p!=NULL)之间加上代码:printf("hehe\n"); 这样a原
//    运行结果为：10.                本的内存空间就被覆盖了，*p输出结果就会发生变化.  


//  指针运算：
//     
//              指针+-整数：如有相邻两个元素a,b，a的指针+1表示的就是b的指针.
// 
//              指针-指针：得到的是两个指针之间的元素个数.
//                   注意：指向同一块空间的两个指针才能相减(两个数组间指针不能相减，同一个数组中指针可以相减).
//                         指针与指针不能相加，因为无意义.


//  二级指针： 是存放一级指针变量的地址.
//          int main()
//          {
//             int a=10;
//             int* pa=&a;           pa是一个一级指针变量.
//             int** ppa=&pa;        ppa是一个二级指针变，通过ppa访问a需要解引用两次(第一次访问pa，第二
//             return 0;             次访问a).
//          }
//          
//          注意：a有地址，pa虽然是指针，但同样也有地址(地址的地址).
//                int** ppa中int*是说明ppa所指的对象是int*类型，第二个*说明ppa是指针.


//  结构体：  把一些单一类型组合在一起(是自定义类型的一种).
//            结构是一些值的集合，这些值称为成员变量.
// 
//    结构体的声明：
//        struct tag             struct是结构体的关键字，tag是结构体标签(结构体名).
//       {
//           member-list;        member-list是成员列表.
//       }variable-list;         variable-list是变量列表(通过struct tag结构类型创建的变量).
//       
// 
//       用法如下：
//          struct Student                         struct是结构体关键字，Student是定义的结构体名字.
//          {
//             char name[20];                      struct{}里的是结构体成员.
//             int age;
//             char sex[5];
//             char tele[12];
//           };                                    此行的;不能省略.
//          int main()
//          {  
//             struct Student s={"zhangsan",20,"nan","155876463728"};     
//             printf("%s %d %s %s\n",s.name,s.age,s.sex,s.tele);        结构体.成员名(s.name,其中.是操作符).
//             return 0;
//          } 
//            运行结果为：zhangsan 20 nan 155876463728.
//
//     注意：在声明结构体时创建的变量是全局变量，所以创建结构体变量时尽量在主函数(main)中创建.
//           结构体成员的类型可以是标量、数组、指针、其它结构体.


// 结构体的多种格式
// 
//  如下：viod print(struct Stu *ps)
//          {
//             printf("%s %d %s %s\n",(*ps).name,(*ps).age,(*ps).sex,(*ps).tele);     指针.成员名
//             printf("%s %d %s %s\n",ps->name,ps->age,ps->sex,ps->tele);       结构体变量->成员名(->是操作符)
//           }
//          int main()
//          {
//             struct Stu s={"zhangsan",20,"nan","155876463728";
//             printf(&s);
//             rerutn 0;
//          }  
//          运行结果为：zhangsan 20 nan 155876463728
//                      zhangsan 20 nan 155876463728.
//      注意：->和.操作符使用的场景不同，得到的是指针可以用箭头，得到的是结构体变量可以用点.
//
//
//      注意：结构体传参的时候，要传结构体的地址.
//           (原因：函数传参的时候，参数是需要压栈的，所以如果传入一个结构体对象的时候，结构体过大，参数压栈
//            的系统开销比较大，所以会导致性能的下降).

//  访问一个结构的成员的两个方法：
//       结构体.成员名
//       结构体指针-＞成员名
//     其中 . 和 -＞ 都是结构成员访问操作符.
//     注意：ps-＞age与(*ps).age表达的意思是一样的.


//  if语句格式：
//              if(表达式)
//              {
//                  语句;                 如果是一句语句可以不写{}，是多句需要写{}.
//              }
//              else if(表达式)
//              {
//                  语句;                 如果是一句语句可以不写{}，是多句需要写{}.
//              }
//              else
//                  printf("语句");
//              return 0;
//          注意：if执行的话，else if和else就不会执行(三个中只会执行一个).


//  C语言中规定0为假，非0为真.
//      注意：int age=10;
//            if(18<=age<25)
//              printf("青年");
//            运行结果为：青年.(因为18<=age,即18<=10不成立，为假，即0<25，为真，所以输出青年).


//  代码写法优化：int num=5;
//                if(num==5)               此行改为if(num=2)            改为if(5=num)
//                printf("hehe\n");
//                运行结果为：hehe.        运行结果为：hehe.(非0为真)   运行错误(5是数字，无法对其赋值).
//
//                                         改为if(5==num)
//
//                                         运行结果为：hehe.
//         综上所述：if(5=num)为最优写法.


//  局部变量必须初始化.
//    如：int main()
//        {
//           int a;
//           printf("%d\n",a);
//           return 0;
//         }
//        编译器会报错.
// 
//  全局变量可以不初始化，编译器会默认它的值为0或空.
//   如：int a;
//       int main()
//       {
//           printf("%d\n",a);
//           return 0;
//        }
//       运行结果为：0或无.


//  switch语句格式：
//                   int main()
//                   {
//                       int day=0;
//                       scanf("%d",&day);
//                       switch(day)                         switch()中的()里只能放整形表达式.(如int
//                       {                                   day=0中的day,float day=1.0中的day就不行).
// 
//                          case 1:                          case后面接整形常量表达式(如1行，1.0不行，
//                                   printf("星期一\n");     注意：字符也是整形,因为字符存储的是其
//                                   break;                  ASCII码值).
//                          case 2:
//                                   printf("星期二\n");       
//                                   break;                  case和default的位置任意(case可以在前也可以在后).
//                          case 3:                          
//                                   printf("星期三\n");
//                                   break;
//                          case ...:
//                                   break;
//                          default:
//                                   printf("选择错误\n");   预防输入的数不包含在case中.
//                                   break;
//                       }
//
//     简化操作：switch(day)
//               {
//                   case 1:
//                   case 2:                 
//                   case 3:
//                   case 4:
//                   case 5:
//                           printf("weekday\n");
//                           break;
//                   case 6:
//                   case 7:
//                           printf("weekend\n");
//                           break;
//                   default:
//                           ptinrf("选择错误\n");
//                           break;
//                }
//              这样输入1,2,3,4,5均输出weekday,输入6,7均输出weekend.


//  while语句格式：
//                  int main()
//                  {
//                     int i=1;
//                     while(i<=10)
//                     {  
//                        if(5==i)
//                        break;               break终止本次循环.        continue会跳过后面的操作，直接
//                        printf("%d",i);                                回到while循环开头进行下一次循环
//                        i++;                                           的判断.(如此处改为continue后运
//                      }                                                行结果为1,2,3,4死循环).
//                     return 0;
//                   }
//                   运行结果为：1,2,3,4.


//  getchar、putchar和scanf的运用：都是对缓冲区的处理.
// 
//         getchar是指标准输入读取一个字符(如：int ch=getchar()，意思是等待用户输入一个字符，然后
//         将该字符的ASCII码值赋给变量ch).
// 
//         putchar是指将一个字符输出到标准输出(如：屏幕)，例如：char ch='A'; putchar(ch);,即将'A'输出
//         到屏幕上(putchar与printf相似).
// 
//         scanf在缓冲区中发现空格就不再读取.
// 
//         用户在输入字符的时候，会按回车确定，此处的回车会编译为'\n'(所以'\n'即为用户时输入的最
//         后一个字符).
// 
//     举例：
//            char password[20]={0};
//            printf("请输入密码：");
//            scanf("%s",password);              此处的password可以不用谢&符号，因为password是数组，
//            while((ch=getchar())!='\n')        数组本身就包含了地址.
//            {
//                ;                              此处代码意思是不断读取输入的字符，直到读取到'\n'(即
//            }                                  最后一个字符)，目的是防止下一行的确认密码的代码直接
//            printf("请确认密码(YES/NO):");     读取了用户之前输入的密码字符所剩下的scanf未读取到的
//            int ret=getchar();                 输部分，导致直接出结果.
//            if('YES'==ret)
//            {
//               printf("YES\n");
//            }
//            else
//            {
//               printf("NO\n");
//            }
//            运行结果： 输入abcdef shdi回车
//                       scanf读取abcdef,读取到空格的时候结束.
//                       在while循环中读取完剩余部分(即 shdi'\n'，即空格shdi回车).
//                       输入YES执行if语句，输入NO执行else语句.
// 
//                       如果没有while循环，printf("请确认密码(YES/NO)：");会直接读
//                       取剩余部分，即 shdi'\n'==ret不成立，为假，执行else语句，
//                       输出结果为NO.


//  域宽： 
//          int year=0;                                    题目要求year为4位数.
//          int month=0;                                   题目要求month为2位数.
//          int date=0;                                    题目要求date为2位数.
//          scanf("%4d %2d %2d",&year,&month,&date);       %4d和%2d即控制了year和month的域宽.
//                                                         (即year需要输入4位数，month需要输入
//                                                         2位数，date需要输入2位数).
//          printf("year=%d\n",year);                 
//          printf("month=%2d\n",month);                   此行代码表示打印的month为2位数，如果输入
//                                                         month为02，则输出为 2(空格2)，因为此处没
//                                                         有写%02d，编译器会默认不够位数的地方为空格.
//                                                         
//          printf("date=%02d\n",date);                    此行代码的%02d表示打印的date为2位数，
//          return 0;                                      如果输入07，则输出07.


//  for循环：
// 
//     语法结构：for(表达式1;表达式2;表达式3)
//               {   
//                  循环语句;
//               }                               注意:有的情况()可以省略.
//            编译时第一步执行表达式1和2,第二步执行循环语句,第三步执行表达式3,重复循环.
//
//          表达式1为初始化部分,初始化循环变量(有时可以省略,但是建议不省略).
//             如：int i=0;                                  int i=0;
//                 for(;i<3;i++)      此处省略了i=0          int j=0;
//                 {                                         for(;i<3;i++)          此处省略了i=0
//                   printf("hehe\n");                       {  
//                 }                                            for(;j<3;j++)       此处省略了j=0
//              运行结果为:3个hehe.                             {
//                                                                 printf("hehe\n")
//                                                              }
//                                                           }
//                                                          return 0;
//                                                          }
//                                                          运行结果为:3个hehe.
//                                                                     因为在第二个for中执行完三次后for变
//                                                                     为3,回到第一个for中执行i=2以及i=3
//                                                                     时j都为3,不会进行第二个for循环,
//                                                                     如果j=0不省略运行结果为9个hehe.
//             总结：外层可以省略,内层不可以省略.
//         
//          表达式2为条件判断部分,判断循环终止.
//          表达式3为调整部分,调整循环条件.
// 
//          注意：如果for循环参数部分和循环内部都有i变量，第二次for循环的参数部分i会变成第一次循环结束时的循环体i的值.


//  for(int i=0;i<10;i++)
//     这种写法在C99中支持,但在其它语法中可能不支持,所以尽量把int写在外边.


//  do while循环格式:
//       ine main()
//       {
//          int i=1;
//          do
//          {
//            printf("%d",i);
//            i++;
//          }
//          while(i<=10);
//          return 0;
//       }        
//       运行结果为:1,2,3,4,5,6,7,8,9,10.
//       注意:do后{}中内容是必须做的,与while中条件无关.   


//  折半查找/二分查找:
//       int main()
//       {
//          int arr[]={1,2,3,4,5,6,7,8,9,10};
//          int k=7;
//          int i=0;
//          int sz=sizeof(arr)/sizeof(arr[0]);
//          int left=0;
//          int right=sz-1;
//          while(left<=ight)
//         {
//            int mid=(left+right)/2;                       此行代码存在可能性错误，当left加上right整体
//            if(arr[mid]<k)                                大于int整形表达的最大值时，溢出部分将不会在计
//            {                                             算内，导致最后结果错误，
//               left=mid+1;                                此时应该换一种写法：
//            }                                             int mid=left+(right-left)/2;
//            else if(arr[mid]>k)                           这种写法不会出现溢出，因为right和left都是没有
//            {                                             溢出的数值，相减除2更不会溢出.
//               right=mid-1;
//            }
//            else
//            {
//               printf("找到了，下标为：%d\n",mid);
//               break;
//            }
//            if(left>right)
//            {
//               printf("找不到\n");
//            }
//          }
//            return 0;
//            }
//      详解见B站36集.           注意：无序数组时不能用二分查找.


//  goto语句：可以跳出多层循环.
// 
//     注意：多层循环使用break是达不到的.
//
//   格式如下：int main()
//          ｛
//             again:
//                   printf("hehe\n");
//                   printf("haha\n");
//                   goto again;           此行代码即为跳转到again.
//                   return 0;
//           }


//  例题：关机程序
//       程序运行后，电脑1分钟内关机.
//       如果输入："我是猪"，就取消关机.
//
//   代码如下：#include<stdio.h>
//             #include<string.h>
//             int main()
//             {
//              char input[20]={0};
//              system ("shutdown -s -t 60");
//            again:
//              printf("请注意：你的电脑即将关机，如果输入：我是猪，就取消关机\n");
//              scanf_s("%s",input);
//              if(strcmp(input,"我是猪")==0)
//              {
//                system ("shutdown -a");
//              }
//              else
//              {
//                 goto again;
//              }
//               return 0;
//              }
//       注意：在visual studio中活动解决方案配置需要用Release.


//    void Swap(int *px,int *py)        其中的*px,*py都是形参(实参的一份临时拷贝).
//    {
//      int z=0;                        注意：此处的z=*px,*px=*py,*py=z中的*都不能去掉，如果去掉会变成px和
//      z=*px;                                py这两个指针变量(地址)进行交换，而不是指a与b交换.
//      *px=*py;                              *px指的对象是a，*py指的对象是b.  px和py仅仅是指针变量.
//      *py=z;
//     }
//   int Add(int x,int y)               其中的x,y都是形参.
//    {
//      int z=0;
//      z=x+y;
//      return z;
//    }
//   int main()                                    注意：在Add函数中没有用指针作为形参，因为其中a和b的值
//    {                                                  没有改变，而在Swap函数中用了指针作为形参，因为
//      int a=0;                                         把值传递到函数中去的时候地址发生了变化，如果不用
//      int b=0;                                         指针进行传递的话，到最后会导致无法将改变后的值传
//      scanf_s("%d%d",&a,&b);                           递回原本的变量中.
//      int c=Add(a,b);                            总结：如果需要改变值就用指针来传递(传址调用：可以在函数
//      printf("%d\n",c);                                要内部直接改变外部变量，即在函数内部改变实参)，如
//      printf("交换前：a=%d b=%d\n",a,b);               果不需改变值就可以用原本数据类型来传递(传值调用：
//      Swap(&a,&b);                                     不能在函数内部改变外部变量).
//      printf("交换后：a=%d b=%d\n",a,b);         
//      return 0;
//    }
//  运行结果为：输入  10 20
//                    30
//                    交换前：a=10,b=20
//                    交换后：a=20,b=10.


//  sqrt:是一个数学库函数，叫作开平方.
//   其头文件是<math.h>.


//  数组传参实际上传递的是数组首元素的地址.
//
//  int main()
//  { 
//    int arr[]={1,2,3,4,5,6,7,8,9,10};
//    int sz=sizeof(arr)/sizeof(arr[0]);
//    int ret=binary_search(arr,k,sz);
//    ……
//  }
//  与
//    int main()
//  { 
//    int arr[]={1,2,3,4,5,6,7,8,9,10};
//    int ret=binary_search(arr,k,sz);
//    ……
//  }
//  int binary_search(int arr[],int k)        此处的arr[]形式上是数组，实际是指针.
//  {
//    int sz=sizeof(arr)/sizeof(arr[]);
//   }
//     
//  这两串代码程序最后算出的答案是不同的，因为数组作为实参时传到函数里的有且仅有数组首位元素的指针，所
//  以在导致第二段代码程序中执行的是sz=4或8除以4，而在第一段中是40除以4.


//  bool:布尔类型（在C99中引入的），是用来表示真假的量，为1个字节大小，对应头文件是<stdbool.h>.
// 
//     #include<stdbool.h>
//     bool Add(……)
//     {
//       if(……)
//       {
//         return false;       false就是0.
//       }
//      return true;           true就是1.
//     }


//  链式访问:   printf("％d\n",strlen("abcdef"));
//            strlen的返回值作了printf的参数，这就叫链式访问.
//
//      printf("％d",printf("％d",printf("％d",43);););
//      运行结果为:4321.
//               因为print函数返回值是打印字符的个数，第三个printf打印43，第二个printf打印第三个printf的
//               返回值(43是两个字符，返回值是2)，第一个printf打印第二个printf的返回值，即打印1，最后打印
//               结果即为4321.
// 
//      注意:链式访问前提条件是函数得有返回值.


//  定义函数时要注意规范写法:需要返回时在函数名前加上类型，不需要返回时在函数名前加void.
//    
//     int Add(int x,int y)
//     {
//        printf("hehe\n");
//     }
//      运行结果为:hehe
//               5        此处的5是hehe\n5个字符.
//
//    写了类型不写返回值时，这种写法在一些编译器中可能返回的是函数执行的最后一条指令执行的结果.


//  main函数有三个参数：
//     int main(int argc,char *argv[],char *envp[]).


//  函数的声明：编译器是按照从上到下的顺序执行编译的，所以函数声明应该放在主函数的前面.
//       
//     写法一： 
//       int Add(int,int);             此处可以只写(int,int)，而不写变量名，是因为这里只是声明，告诉编译器
//       int main()                    有这个函数，告诉编译器这个函数叫什么，参数是什么类型，返回类型是什么,
//       {                             当然，写出参数名也没有错，只是与后面定义函数显得有点重复.
//          int a=0;
//          int b=0;
//          scanf_s("%d %d",&a,&b);
//          int sum=Add(a,b);
//          printf("%d\n",sum);
//          return 0;
//       }
//      int Add(int x,int y) 
//      { 
//          return x+y;
//      }
//       
//     写法二： 
//        头文件中：在头文件中添加一个新建项为add.h
//               即int Add(int,int)
//        源文件中：在源文件中添加一个新建项为add.c       其中add.h和add.c这两个文件叫一个模块.
//               即int Add(int x,int y)
//                 {
//                    return x+y;
//                 }
//        主文件中：在最初的那个源文件中
//                 #include<stdio.h>                      <>是库函数用的符号.
//                 #include"add.h"                        ""是自定义函数用的符号.
//                 int main()
//                 {
//                   int a=0;
//                   int b=0;
//                   scanf_s("%d %d",&a,&b);
//                   int sum=Add(a,b);
//                   printf("%d\n",sum);
//                   return 0;
//                 }
//  
//  静态库：将.c文件转换为二进制库，将add.c转换成静态库即为add.lib.
//       使用静态库时在主函数前加#pragma comment(lib,"add.lib")
//     如：
//           在头文件add.h中：int Add(int x,int y);
//           在主文件中：#include<stdio.h> 
//                     #include"add.h"
//                     #pragma comment(lib,"add.lib")             此处是导入静态库.
//                     int main()
//                     {
//                       int a=0;
//                       int b=0;
//                       scanf_s("%d %d",&a,&b);
//                       int sum=Add(a,b);
//                       printf("%d\n",sum);
//                       return 0;
//                     }


//  递归：程序调用自身的编程技巧称为递归.
//    
//       viod print(unsigned int n)
//       {
//          if(n>9)
//          {
//             print(n/10);               此行代码即为递归的实现(具体过程查看B站鹏哥C语言P46 23分).
//           }
//          printf("%d",n%10);            其中的if(n>9)不可以不要，删去的话会造成死递归(即进入递归后出不来)，
//        }                               编译器会报一个叫Stack overflow的错误(即栈溢出)，最后造成程序崩溃，
//       int main()                       因为每一次函数的调用都会在栈区中申请空间.(函数栈区的创建和销毁，查
//       {                                看CSDN软件搜索).
//          unsigned int num=0;
//          scanf_s("%u",&num);
//          print(num);
//          return 0;
//       }   


//  二维数组:
//     创建:int arr[3][4]={1,2,3,4,2,3,4,5,3,4 5,6};
//          int arr[3][4]={{1,2},{3,4},{5,6}};
//          int arr[][4]={1,2,3,4,5,6};
//       这三种方法均可，第一个[]表示行，第二个[]表示列，但实际上二维数组在内存中也是连续存放的(低地址
//       到高地址)，是排成一行的，并不是一个矩阵，一行相当于一个一维数组，这里三行相当于三个一维数组首
//       尾相连着排成了一行.
//       
//  注意:第二种方法，元素是1,2,0,0,3,4,0,0,5,6,0,0，未初始化部分默认为0.    
//       第三种方法，元素是1,2,3,4,5,6,0,0，在二维数组中，行可以不定义，但列必须定义，这里未定义行，编
//       译器会按一行中元素个数算出行数自动排布.
//            
// 
//       用矩阵的形式打印一个二维数组:
//            int arr[3][4]={1,2,3,4,2,3,4,5,3,4,5,6};
//            int i=0;
//            for(i=0;i<3;i++)
//            {
//               int j=0;
//               for(j=0;j<4;j++)
//               {
//                 printf("％d ",arr[i][j]);
//               }
//               printf("\n");
//            }
//            return 0;
//         运行结果为:1 2 3 4
//                    2 3 4 5
//                    3 4 5 6.
//
//
//    打印一个元素:printf("％d ",arr[2][0]);
//               运行结果为: 3.
//        注意:下标是从0开始，三行表示第0行，第1行，第2行，四列表示第0列，第1列，第2列，第3列.
//
//
//    计算行数与列数:printf("％d ",sizeof(arr)/sizeof(arr[0]));   计算行.
//                printf("％d ",sizeof(arr[0])/sizeof(arr[0][0]));   计算列.
//                
//                sizeof(arr)表示整个数组大小，sizeof(arr[0])表示第一行大小，sizeof(arr[0][0])表示
//                第一行第一列的大小.


//  冒泡排序:详细见B站鹏哥P55 57分17秒.


//   正的整数的原码、反码、补码相同，负的整数的原码、反码、补码不相同(需要计算).
//   2进制码第一位为符号位，整数为0，负数为1.
// 
//        计算如下：
//                  10000000000000000000000000000111  原码(此处整型举例，4个字节，32个比特位)
//                  11111111111111111111111111111000  反码(原码的符号位不变，其它位按位取反)
//                  11111111111111111111111111111001  补码(反码加1).
//        注意：整数在内存中存储的是补码.
//              补码求原码时也可以取反加一.


//   连续赋值：a=x=y+1; 从右往左计算.


//  复合赋值符： +=  -=  *=  /=  %=  ＞＞=  ＜＜=  &=  |=  ^=


//  表达式求值：表达式求值的顺序一部分是由操作符的优先级和结合性决定，也有的表达式的操作数在求值过程中需要
//  转换为其它类型.
// 
//  注意：优先级和结合性是对于相邻两个操作符而言，当相邻两个操作符优先级相同时，看结合性.
//  
//  操作符的优先级和结合性查找文件夹：D:\桌面\鹏哥C语言资料\比特鹏哥学习资料\【C语言编程UP主】C语言资料-比
//  特就业课\C语言课件【比特就业课提供】\初级 第5节-操作符详解12.3
//  注意：优先级由上往下是高到底，结合性L指左，R指右，N/A指无结合性.


//  隐式类型转换：C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//                为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为
//                整型提升。
//    
//        如：int main()
//            {
//               char a=5;
//               char b=126;
//               char c=a+b;              char属于整形家族，运算时按照C的整形算术运算，则char进行整形提升，
//               printf("%d\n",c);        转换为int类型.(char是1个字节，大小没达到int类型的大小，需要整形提升).
//               return 0;
//            }
//            运行结果为：-125 (对a,b整形提升，2进制补码相加得到c，再转换为原码计算).
// 
// 
//        整形提升：有符号整形变量按照数据类型的符号位来提升(分为正数和负数).
//                  无符号整型变量，高位补0.
//             
//                  char c1 = -1;
//                  变量c1的二进制位(补码)中只有8个比特位：
//                  1111111
//                  因为 char 为有符号的 char
//                  所以整形提升的时候，高位补充符号位，即为1
//                  提升之后的结果是：
//                  11111111111111111111111111111111.
// 
//                  char c2 = 1;
//                  变量c2的二进制位(补码)中只有8个比特位：
//                  00000001
//                  因为 char 为有符号的 char
//                  所以整形提升的时候，高位补充符号位，即为0
//                  提升之后的结果是：
//                  00000000000000000000000000000001.
 
                     
//  算术转换：当变量类型大小大于等于int类型大小时，会进行类型转换，称为算术转换.
//              
//        转换顺序：long double
//                  double
//                  float
//                  unsigned long int
//                  long int
//                  unsigned int
//                  int
//                 下面的转换为上面的.


//  注意：用操作符时要能确定唯一的计算路径.


//  指针数组：存放指针的数组.
// 
//      int a=10;
//      int b=20;
//      int* parr[10]={&a,&b};           这里parr就是指针数组.
//      int i=0;
//      for(i=0;i<2;i++)
//      {
//         printf("%d",*(parr[i]));
//      }
//      return 0;
//      运行结果为：10 20 30.
//   
//      int arr1[4]={1,2,3,4};
//      int arr2[4]={2,3,4,5};
//      int arr3[4]={3,4,5,6};
//      int* parr[3]={arr1,arr2,arr3};   
//      这里parr[3]就是指针数组.


//  浮点数在内存中不能精确保存.


//  IO型：需要输入、计算、输出.
//  
//  接口型：只需要完成接口函数.


//  strcpy在拷贝字符串时，会把源字符串中的\0也拷贝过去.


//  编程常见的错误：编译型错误(语法错误).
//                  链接型错误(出现自链接期间，找不到符号，要么不存在，要么写错了).
//                  运行时错误(通过调试来解决).


//  任何一个变量或表达式都有两个属性：值属性、类型属性.
//           
//            int a=3;
//            a+4.5;    这个表达式的值属性是7.5，类型属性是double(整形与double相加会算术转换).


//  整形在内存中的存储类型：
// 
//  整形家族：
//            char                                字符的本质是ASCII码值，是整形
//                  unsignded char
//                  signed char
//            short
//                  unsigned short
//                  signed short
//            int
//                  unsigned int
//                  signed int
//            long
//                  unsigned long
//                  signed long
//       long long
//                  unsigned long long
//                  signed long long
// 
//        注意：
//        在int类型中int a; 就是signed int a;
// 
//        在short类型中short a; 就是signed short a;
// 
//        在long类型中long a; 就是signed long a;
// 
//        在long long类型long long a; 就是signed long long a;
// 
//        在char类型中char a; 是signed char a; 还是unsigned char a; 取决于编译器.
//
//
//  浮点型家族：
//              float  double.
// 
//           float的精度低，存储的数值范围较小.
//           double的精度高，存储的数值范围较大.
//                     
//      注意：只要表示小数就可以使用浮点型.
//           
//
//  构造类型：自定义类型(自己创建的新的类型).
//            其中包括数组类型、结构体类型、枚举类型、联合类型.
//            
//            例如：int arr1[5] 数组类型是int [5].
//                  char arr2[4] 数组类型是char [4].
//
// 
//  指针类型：如，int *pi, char *pc, float *pf, void *pv等.
// 
// 
//  空类型：void表示空类型(无类型).
//          通常用于函数的返回类型、函数的参数、指针类型.


//  数据在内存中存储的是2进制的补码，但是在监管中显示的是16进制的，是为了方便程序员查看.


//  2进制转换成16进制：2进制4位化作16进制2位.
// 
//              20的2进制是00000000000000000000000000010100.
//                 16进制是0x00 00 00 14.
// 
//           注意：0x是表示这串数字是16进制.


//  大端字节序存储：把一个数据的高位字节序的内容放在低地址处，低位字节序的内容放在高地址处(正序存储).
// 
//  小端字节序存储：把一个数据的低位字节序的内容放在低地址处，高位字节序的内容放在高地址处(逆序存储).

//  for循环中
//       
//       注意:如果int i=0;写在循环体外边，则for循环结束后i的值会改变(即循环结束时的值).
//            如果写在循环体里边，则for循环结束后i的值不会延伸到外部(i的值也是循环结束时的值，但是只在循环体里边生效).


//  在 C 语言中，如果程序没有释放动态分配的内存(通过malloc/calloc/realloc分配的内存,如链表节点)，但正常退出(例如用户主动关闭程序)
//  内存泄漏的后果取决于操作系统的行为：
//      操作系统会回收进程的所有内存,
//      现代操作系统（如 Windows、Linux、macOS）在进程正常退出时，会自动回收该进程占用的所有内存资源，包括未释放的动态内存。
//        因此：
//        短期程序：即使存在内存泄漏，程序退出后，操作系统会清理这些内存，不会影响系统整体性能。
//        内存泄漏的真正风险：主要针对需要长期运行的程序（如服务器、守护进程），因为它们不会频繁重启，泄漏的内存会持续积累。


//  链表中，前一个数据中存放的是后一个数据的地址，如curt->next指的是curt这个数据的后一个数据的地址，curt=curt->next就是把
//          curt往后移一位(即curt指向了curt后面的那个数据).

//  P99往后
//
